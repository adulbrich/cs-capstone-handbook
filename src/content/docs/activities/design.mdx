---
title: Design Activities
description: Explore technical and visual design activities for your capstone project, including architecture, prototyping, technology evaluation, database design, accessibility, and security best practices.
sidebar:
  order: 4
---

import { Badge } from '@astrojs/starlight/components';

Design activities focus on both the technical and visual aspects. Activities tackle either one or the other. These activities will help you figure out what you need to implement and how you will make your software available (deployment).

> "Design is not just what it looks like and feels like. Design is how it works." -- Steve Jobs

{/* https://www.nngroup.com/articles/accessibility-inclusivity-study-guide/ */}

## Complete a Tutorial
{/* consider moving this to another section */}

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Gain hands-on experience and enhance your technical skills by completing a tutorial relevant to your project.

1. Choose a Tutorial: Select an online tutorial that aligns with your project (e.g., database setup, API development, UI design, web framework).
2. Work Through the Steps: Complete the tutorial, following the instructions and applying what you learn.

:::note
Consider doing one or more "Quick Start" guides to compare different technologies instead of an in-depth tutorial, see the [Evaluate Different Technologies](#evaluate-different-technologies) activity.
:::

Write a summary of what you learned and how you will apply it to your project. Outline features, if any, that you learned about and how it will help with specific concerns or features.

## Select a Database or Storage Technology

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Choose the most suitable database or storage technology for your project based on data requirements, scalability, and use case.

- Assess Requirements: Analyze your project's data structure, volume, and usage patterns.
- Compare Options: Explore relational (e.g., MySQL, PostgreSQL) vs. non-relational databases (e.g., MongoDB, Cassandra), as well as different ways to store data (offline, online, object stores, etc.).
- Scalability and Performance: Consider factors like read/write speeds, scalability, and how well the database or store handles your expected workload.
- Final Selection: Justify your choice based on how it aligns with the project's goals.

Provide a report detailing the options considered, pros/cons, and rationale for your final database/storage selection.

## Define your Database Schema

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Design a structured database schema to organize and store your project's data effectively.

- Identify Entities: List all the key entities (e.g., users, orders, products) relevant to your project.
- Define Relationships: Determine how entities relate to each other (e.g., one-to-many, many-to-many).
- Create Tables and Fields: Design the tables and define attributes (fields) for each entity.
- Normalize Data: Ensure your schema minimizes redundancy through normalization.
- Performance: Index key fields for faster querying and optimize design for scalability.
- Security Measures: Plan data encryption, define access controls, and ensure proper handling of sensitive data (e.g., user passwords).

Submit your database schema diagram with explanations of the relationships, key tables or objects, and fields. Explain how normalization was used, and which performance and security considerations you plan to implement. Optionally, submit a schema configuration file (e.g., SQL query to create the tables).

## Evaluate Different Technologies

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Compare and assess multiple technologies (e.g., languages, frameworks, libraries, ...) to choose the best fit for your project's requirements.

- Identify Key Criteria: Define what you need from the technology (e.g., performance, scalability, ease of use, ...).
- Research Options: Explore 2-3 technology solutions and their strengths/weaknesses.
- Compare Performance and Compatibility: Evaluate how well each technology integrates with your existing project and meets performance goals.
- Security and Support: Consider security features and available community support for each option.

Provide a comparison matrix and a justification for the chosen technology.

## ðŸ”¥ Describe your Architecture

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Clearly define the overall system architecture of your project, focusing on key components and how they interact.

- Identify Core Components: List and describe major components (e.g., frontend, backend, database, external APIs, functions, data sources, ...).
- Define Interactions: Explain how components communicate (e.g., API calls, data flows).
- Consider Scalability: Discuss how the architecture handles future growth.
- Security and Performance: Identify security measures and performance optimization techniques integrated into the architecture.

Submit a diagram of the architecture and a brief explanation of each component and its role in the system.

## High-Fidelity Prototype

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Develop a high-fidelity prototype to visualize and refine the design of your project, ensuring alignment with user experience and technical requirements.

- Design User Flows: Create a detailed prototype showcasing key user interactions and functionality using tools like Figma or Adobe XD.
- Visual Consistency: Ensure the design adheres to UI/UX principles and branding guidelines.
- Gather Feedback: Share the prototype with stakeholders or users to refine the design based on feedback.

Check this fantastic [blog post about a SoundCloud iOS redesign](https://www.freecodecamp.org/news/my-friends-hate-soundcloud-ios-so-i-redesigned-it-for-them-d3038cdd020b).

Submit the prototype link and a reflection on design choices and feedback incorporated.

## Proof-of-Concept

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Build a small-scale prototype or demo to test the feasibility of a specific idea, technology, or approach within your project.

- Define Key Assumptions: Identify the core concept or functionality that needs validation.
- Develop the Prototype: Create a minimal version focusing on the critical feature or technology.
- Test Feasibility: Evaluate the proof-of-concept to ensure the technology or idea works as intended.

Submit the proof-of-concept and a brief report on its feasibility, challenges encountered, and potential next steps.

## Test Plan

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Develop a comprehensive [test plan](https://en.wikipedia.org/wiki/Test_plan) to ensure your project's functionality, performance, and reliability.

1. Identify Test Objectives: Define what you need to test (e.g., functionality, usability).
2. Create Test Cases: Develop detailed test scenarios for each feature.
3. Determine Test Methods: Choose manual or automated testing.
4. Set Success Criteria: Define what constitutes a pass/fail result.

Submit a test plan document outlining test cases, methods, and criteria. 

## Deployment Plan

<Badge text="Individual Activity" variant="success" class="mb-6"/>

[Software deployment](https://en.wikipedia.org/wiki/Software_deployment) is all the things that need to happen for a software system to be  available for use.

Outline the steps needed to either:

- deploy your project to a production environment or app store, 
- build your software and make it available for download.

That means:

1. Identify Deployment Environment: Specify where your software will be deployed (e.g., cloud, server) or where artifacts will be stored.
2. Create a Deployment Checklist: Include steps like configuration, testing, build, integration, uploads, release, and backups. 
3. Define Rollback Plan: Plan actions if deployment fails.

Submit a deployment plan detailing environment, steps, and rollback procedures.

## Describe your API Reference

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Develop a comprehensive API reference to document the functions, endpoints, and data structures of your project's application programming interface (API).

1. List API Endpoints: Document each endpoint, including URL paths and methods (GET, POST, etc.).
2. Define Inputs/Outputs: Clearly specify the required parameters, data types, and response formats for each endpoint.
3. Document Error Handling: Include examples of error messages and how to handle them.

Provide the complete API reference document and a sample request/response for each endpoint.

## Apply the Privacy by Design (PbD) Guidelines

<Badge text="Individual Activity" variant="success" class="mb-6"/>

[Privacy by Design](https://en.wikipedia.org/wiki/Privacy_by_design) is a systems engineering approach developed by Ann Cavoukian, former Information & Privacy Commissioner of Ontario. 

The [seven foundational principles](https://www.ietf.org/ietf-ftp/slides/slides-privacyws-privacy-by-design-the-seven-foundational-principles-00.pdf) are:

1. Proactive not reactive; preventive not remedial
2. Privacy as the default setting
3. Privacy embedded into Design
4. Full functionality -- positive-sum, not zero-sum
5. End-to-end security -- full lifecycle protection
6. Visibility and transparency -- keep it open
7. Respect for user privacy -- keep it user-centric

Read the principles in detail, then write a report that explains how your software implements each one, or what needs to be done to get there. 

## UI Design Guidelines

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Select an appropriate set of user interface guidelines and apply them.
There are user interface guidelines published by free/open-source
organizations, corporations, and even government. Here are some
examples:

- [Microsoft's Fluent 2 Design System](https://fluent2.microsoft.design/)
- [Google's Material 3 Design System](https://m3.material.io/)
- [Adobe's Spectrum Design System](https://spectrum.adobe.com/)
- [Firefox's Acorn Design System](https://acorn.firefox.com/)
- [Atlassian's Design Language](https://atlassian.design/)
- [KDE Human Interface Guidelines](https://develop.kde.org/hig/)
- [GNOME Human Interface Guidelines](https://developer.gnome.org/hig/index.html)
- [Apple Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/)
- [Digital.gov's Usability](https://digital.gov/topics/usability/)

Feel free to come up with another design system or your own exhaustive one.

Submit your updated UI wireframes or a demo of your updated software with a summary of what changed and why.

## Apply the GenderMag Method

<Badge text="Individual Activity" variant="success" class="mb-6"/>

The [GenderMag Method](https://gendermag.org/index.php) enables software practitioners (e.g., developers, managers, UX professionals) to find gender-inclusivity "bugs" in their software, and then fix the bugs they find.

Apply the method and write a summary of your findings and what you will change in your software.

{/* ## Peer UI Design Review

<Badge text="Individual Activity" variant="success" class="mb-6"/>
<Badge text="Team Activity" variant="note" class="mb-6"/> */}

{/* ## Peer Design Exploration */}

{/* Every team is expected to provide, in advance of class, a brief (one page maximum) description of at least one (possibly two) design challenge(s). This description may be diagrammatic or textual or some combination thereof. The challenge might concern fitness for purpose or fitness for future. When in consulting role, each team is expected to provide at least two alternative solutions to the other team's presented design challenge.*/}

## Peer Technical Design Review

<Badge text="Individual Activity" variant="success" class="mb-6"/>
<Badge text="Team Activity" variant="note" class="mb-6"/>

In this activity, find two other teams to run a technical design review, either on Zoom or in person.

Your team will receive reviews from two other teams and will review these two teams. 

As the reviewing team, your job is to think critically about the other team's design: 

- Does the design report address the questions below?
- Is the design fit for purpose? Does it meet the specification?
- Is the design fit for the future? Can it grow modularly?
- Does the code implement the design? (look at the code!)
- Is the design solving the right problem?
- Are there design alternatives that should be considered?
- Are there coding issues that should be addressed?

Submit your report (see below) and your consolidated reviews (from each member of the team). Share your review with the corresponding team. This activity can either be individual (one person from each team) or team (everyone on the team reviews both other teams).

Your report should be a one page diagram and one page of text covering the following three issues:

### Explanation of the Design

This exercise is focused on the internal design and architecture of the software -- not the user experience.

- What are the components? 
- What libraries and tools are used? 
- How are they arranged? 
- Any noteworthy uses of architectural styles or design patterns?
- etc.

### Fitness for Purpose

A rationale for why this design meets the requirements/specification.

- Why is this design better than reasonable alternatives? 
- If the project is in a known domain with a known solution strategy, is it following normal design conventions? 
- If the project is in a novel domain or has a novel solution strategy, why is the proposed design a good match?

### Fitness for Future

- What are the anticipated kinds of change, growth, or variability in the domain?
- Does the design facilitate managing that change in a modular fashion? 
- What are core assumptions that cannot be changed?

## Read a Book on Approaches to Software Design

<Badge text="Individual Activity" variant="success" class="mb-6"/>
<Badge text="Team Activity" variant="note" class="mb-6"/>

Take a look at a book about software design, and discuss in the context of your project. One good approach is that each team member skims several chapters, so that collectively you have examined the entire book. The books listed here are a starting point; you might find other interesting books worth reading.

Submit a write-up of what you learned and how you will apply it to your project.

- [Clean Architecture](https://www.goodreads.com/book/show/18043011-clean-architecture) by Robert C. Martin
- [Release It!: Design and Deploy Production-Ready Software](https://www.goodreads.com/book/show/1069827.Release_It_) by Michael T. Nygard
- [A Philosophy of Software Design](https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design) by John Ousterhout
- [Software Design Decoded: 66 Ways Experts Think](https://www.goodreads.com/book/show/29889476-software-design-decoded) by Marian Petre and AndrÃ© van der Hoek
- [Software Designers in Action: A Human-Centric Look at Design Work](https://www.goodreads.com/book/show/16236113-software-designers-in-action) by Marian Petre and AndrÃ© van der Hoek
- [Designing Secure Software: A Guide for Developers](https://www.goodreads.com/book/show/58877754-designing-secure-software) by Loren Kohnfelder

## Create Good Survey or Interview Questions

<Badge text="Individual Activity" variant="success" class="mb-6"/>

If you are collecting data through surveys or interviews, it's very important to have clear, unbiased, valuable, and not leading questions, i.e., [good questions](https://owl.purdue.edu/owl/research_and_citation/conducting_research/conducting_primary_research/interview_and_survey_questions.html). You'll also have to consider what type of data (qualitative, quantitative) you're collecting, their purpose, and how you are going to analyze the answers.

For this activity, explain what medium you will use to collect the answers, write your survey or interview questions, the expected types of answers for each, and how you will use them for analysis and answering your research question(s).

## Planning for Maintenance and Long-Term Support

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Identify key factors for maintaining and supporting the system post-deployment to ensure long-term sustainability.

Instructions:

- Define Maintenance Tasks: List regular maintenance tasks (e.g., backups, updates, bug fixes).
- Plan for Scalability: Outline strategies for scaling the system as usage grows.
- Support Structure: Identify the team or resources responsible for providing user support and resolving issues.
- Create Documentation: Develop a plan for user manuals, FAQs, and support guides.

Provide a detailed plan addressing maintenance, scalability, and user support.

## Optimizing System Performance

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Identify and address factors that influence system performance to ensure optimal operation under different loads.

- Define Performance Metrics: Identify key metrics like response time, throughput, and latency.
- Plan for Load Handling: Evaluate how the system will handle different levels of traffic (e.g., stress testing, load balancing).
- Optimize Code and Queries: Identify areas for improving efficiency (e.g., database indexing, caching).
- Monitoring and Scaling: Plan for performance monitoring tools and strategies for scaling.

Provide a performance plan with identified bottlenecks and optimization strategies.

## Designing for System Security

<Badge text="Individual Activity" variant="success" class="mb-6"/>

Ensure the system is designed with robust security measures to protect data and user privacy.

- Identify Vulnerabilities: List potential security risks (e.g., data breaches, unauthorized access).
- Implement Best Practices: Plan for security measures such as encryption, authentication, and role-based access control.
- Secure Data: Outline how sensitive data will be protected both in transit and at rest.
- Compliance and Monitoring: Ensure the system meets security standards (e.g., GDPR, HIPAA) and establish regular monitoring for threats.

Submit a security plan that details risks, countermeasures, and compliance strategies.

## MDA Framework

<Badge text="Individual Activity" variant="success" class="mb-6"/>
<Badge text="Team Activity" variant="note" class="mb-6"/>

Use the MDA (Mechanics, Dynamics, Aesthetics) framework to analyze and structure your game before development begins. This activity helps your team clarify the intended player experience, define core mechanics, and anticipate how game dynamics will emerge. Complete this activity to align on design goals and make informed decisions early in the process. You can split different parts of the MDA framework among team members.

## Fun Hypotheses

<Badge text="Individual Activity" variant="success" class="mb-6"/>
<Badge text="Team Activity" variant="note" class="mb-6"/>

Identify and articulate your team's hypotheses about what will make your game fun and engaging. This activity helps you focus design efforts on the elements most likely to delight players and provides a basis for testing and iteration throughout development.

## Core Loop Analysis

<Badge text="Individual Activity" variant="success" class="mb-6"/>
<Badge text="Team Activity" variant="note" class="mb-6"/>

Identify and refine the fundamental repeatable actions that drive engagement and progression in your game. This activity helps you ensure your game provides meaningful and satisfying interactions. Use core loop analysis to iterate on your design and improve player retention and enjoyment.

## Player Journey

<Badge text="Individual Activity" variant="success" class="mb-6"/>
<Badge text="Team Activity" variant="note" class="mb-6"/>

Map out the player's journey from the First Time User Experience (FTUE) through the mid-game. This activity helps your team visualize onboarding, learning curves, and progression, ensuring that players are supported and engaged as they move deeper into the game. Use this to identify potential drop-off points and opportunities to enhance player satisfaction.

{/* ## Peer UI Design Review

<Badge text="Individual Activity" variant="success" class="mb-6"/>
<Badge text="Team Activity" variant="note" class="mb-6"/> */}

{/* ## Peer Design Exploration */}

{/* Every team is expected to provide, in advance of class, a brief (one page maximum) description of at least one (possibly two) design challenge(s). This description may be diagrammatic or textual or some combination thereof. The challenge might concern fitness for purpose or fitness for future. When in consulting role, each team is expected to provide at least two alternative solutions to the other team's presented design challenge.*/}